#学习笔记

##哈希表、映射、集合
 - Hash table
 - 散列表
 - 根据关键码值（Key value）而直接进行访问的数据结构。
 - 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
 - 这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表。
 - 在我理解，就是用一个数组去存数据，但是，在插入数据时，不再是按顺序插入。
 - 而是，先通过哈希函数计算出一个index，将数据插入到这个位置。
 - 这样，如果哈希函数设计的足够巧妙，保证每个数据经过哈希函数计算后的index不同的话，就可以使插入近乎O(1)时间复杂度，因为无需移动元素。
 - 而且，查找的时间复杂度也近乎O(1)，因为直接通过哈希函数计算得出index，无需遍历查询。
 - Java中的hashmap原来1.8之前就是用数组加链表实现的，之后是数组加链表，如果链表长度大于等于8，将链表转换成红黑树。如果两个值经过哈希函数计算得出的index相同，就称为哈希碰撞。
 - 如果，碰撞太频繁的话，链表过长，就会退化成链表，查询时间复杂度退化成O(n)，因为需要遍历链表。

##树、二叉树、二叉搜索树
 - 树其实就是特殊的链表，不只有一个next指针，而是有一个以上next指针的链表。
 - 图其实就是特殊的树，有环存在的树就是图。
 - 二叉搜索树，有序的，对标有序数组的二分查找。

##堆和二叉堆、图
 - 大顶堆，小顶堆。查找一堆数中最大的或最小的，O(1)时间复杂度。
 - 常见的有二叉堆（由完全二叉树实现，即除了叶子节点都是满的），斐波拉契堆（由n叉树实现）。二叉堆是最简单的实现，但是性能其实是最差的，只是刚刚好满足条件。
 - 二叉堆一般由数组实现，层序遍历，数组中依次放入。根节点为a[0]。下标index为i的节点，父节点为floor((i-1)/2)(此处的floor是取整，不足1为0)，左子节点为i*2+1，右子节点为i*2+2 
